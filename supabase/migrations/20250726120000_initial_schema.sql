/*
  # Initial Schema for DoEase

  This script sets up the initial database schema for the DoEase application.
  It includes tables for user profiles and tasks, enables Row Level Security (RLS)
  for data protection, and creates policies to ensure users can only access their own data.
  It also includes a trigger to automatically create a user profile upon new user sign-up.

  ## Query Description: This is a structural setup for a new database.
  - It creates two new tables: `profiles` and `tasks`.
  - It links the `profiles` and `tasks` tables to Supabase's built-in `auth.users` table.
  - It enables Row Level Security on these tables, which is a critical security measure. By default, no data will be accessible until policies are created.
  - It adds policies that allow users to view and manage only their own profiles and tasks.
  - It creates a function and trigger to automatically populate the `profiles` table when a new user is created in the authentication system.
  - There is no risk of data loss as this is an initial setup.

  ## Metadata:
  - Schema-Category: "Structural"
  - Impact-Level: "Low"
  - Requires-Backup: false
  - Reversible: true (by dropping tables, policies, and the trigger)

  ## Structure Details:
  - Tables Created:
    - `public.profiles`: Stores user-specific public data like username.
    - `public.tasks`: Stores tasks created by users.
  - Columns Added:
    - `profiles`: `id` (PK, FK to auth.users), `username`, `updated_at`.
    - `tasks`: `id` (PK), `user_id` (FK to auth.users), `created_at`, `name`, `start_time`, `end_time`, `due_time`, `priority`, `completed`.
  - Functions Created:
    - `public.handle_new_user()`: Trigger function to create a profile.
  - Triggers Created:
    - `on_auth_user_created`: Fires after a new user is inserted into `auth.users`.

  ## Security Implications:
  - RLS Status: Enabled on `profiles` and `tasks`.
  - Policy Changes: Yes, new policies are created to enforce data isolation between users.
    - Users can SELECT, UPDATE their own profile.
    - Users can perform all CRUD operations on their own tasks.
  - Auth Requirements: Policies rely on `auth.uid()` to identify the current user.

  ## Performance Impact:
  - Indexes: Primary keys are automatically indexed. A foreign key index is created on `tasks.user_id`.
  - Triggers: One trigger is added to `auth.users`, which has a minimal performance impact on user creation.
  - Estimated Impact: Low. The schema is simple and well-indexed for the expected query patterns.
*/

-- 1. Create Profiles Table
-- Stores public user information.
CREATE TABLE public.profiles (
  id UUID NOT NULL REFERENCES auth.users ON DELETE CASCADE,
  username TEXT,
  updated_at TIMESTAMPTZ DEFAULT NOW(),

  PRIMARY KEY (id),
  CONSTRAINT username_length CHECK (char_length(username) >= 3)
);

COMMENT ON TABLE public.profiles IS 'Public profile information for each user.';

-- 2. Create Tasks Table
-- Stores tasks for each user.
CREATE TABLE public.tasks (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES auth.users ON DELETE CASCADE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    name TEXT NOT NULL,
    start_time TIME,
    end_time TIME,
    due_time TIMESTAMPTZ,
    priority TEXT DEFAULT 'low'::TEXT,
    completed BOOLEAN NOT NULL DEFAULT FALSE
);

COMMENT ON TABLE public.tasks IS 'Stores all tasks created by users.';

-- 3. Set up Row Level Security (RLS)
-- Enable RLS for the new tables.
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.tasks ENABLE ROW LEVEL SECURITY;

-- 4. Create RLS Policies
-- Policies for the 'profiles' table.
CREATE POLICY "Public profiles are viewable by everyone."
  ON public.profiles FOR SELECT
  USING ( true );

CREATE POLICY "Users can insert their own profile."
  ON public.profiles FOR INSERT
  WITH CHECK ( auth.uid() = id );

CREATE POLICY "Users can update their own profile."
  ON public.profiles FOR UPDATE
  USING ( auth.uid() = id );

-- Policies for the 'tasks' table.
CREATE POLICY "Users can view their own tasks."
  ON public.tasks FOR SELECT
  USING ( auth.uid() = user_id );

CREATE POLICY "Users can insert their own tasks."
  ON public.tasks FOR INSERT
  WITH CHECK ( auth.uid() = user_id );

CREATE POLICY "Users can update their own tasks."
  ON public.tasks FOR UPDATE
  USING ( auth.uid() = user_id );

CREATE POLICY "Users can delete their own tasks."
  ON public.tasks FOR DELETE
  USING ( auth.uid() = user_id );


-- 5. Create Trigger for New User Profiles
-- This function is triggered when a new user signs up.
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER SET search_path = public
AS $$
BEGIN
  INSERT INTO public.profiles (id, username)
  VALUES (new.id, new.raw_user_meta_data->>'username');
  RETURN new;
END;
$$;

-- The trigger that calls the function.
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();
